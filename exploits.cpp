/***********************************************************************
 * Program:
 *    Lab 08, Vulnerabilities and Exploits
 *    Brother Wilson, CS470
 * Author:
 *    Spencer Browning
 * Summary:
 *    This program is designed to demonstrate memory injection vulnerabilities.
 *
 ************************************************************************/

#include <iostream>
#include <cassert>
using namespace std;

void stackExploit();
void heapExploit();
void arrayExploit();
void intExploit();
void arcExploit();
void subterfugeExploit();
void vtableExploit();
void ansiExploit();
void stackSmasher();

/******************************************************
 * MAIN
 * This function take you to the various exploits
 *****************************************************/
int main()
{
    // prompt
    cout << "  1. Stack smashing\n"
    << "  2. Heap spraying\n"
    << "  3. Array index\n"
    << "  4. Integer overflow\n"
    << "  5. ARC injection\n"
    << "  6. Pointer subterfuge\n"
    << "  7. VTable spraying\n"
    << "  8. ANSI-Unicode conversion\n"
    << "> ";
    int select;
    cin >> select;
    
    switch (select)
    {
        case 1:
            stackExploit();
            break;
        case 2:
            heapExploit();
            break;
        case 3:
            arrayExploit();
            break;
        case 4:
            intExploit();
            break;
        case 5:
            arcExploit();
            break;
        case 6:
            subterfugeExploit();
            break;
        case 7:
            vtableExploit();
            break;
        case 8:
            ansiExploit();
            break;
        default:
            cout << "Unknown option " << select << endl;
    }
    
    return 0;
}

/**************************************************************
 **************************************************************
 *******************    SUBTERFUGE    *************************
 **************************************************************
 **************************************************************/

/****************************************
 * Pointer Subterfuge Vulnerability
 * 1. There must be a pointer used in the code.
 * 2. There must be a way to overwrite the pointer
 * 3. After the pointer is overwritten, the pointer is dereferenced
 ****************************************/
void subterfugeVulnerability(long * array, int size)
{
    long int buffer[2] = {0, 1};
    const char * message = "All is safe; nothing bad happened\n";  // 1. Pointer
    
    for (int i = 0; i < size; i++)  // 2. Overwrite
        buffer[i] = array[i];
    
    cout << message;                // 3. Dereference
    
}

/****************************************
 * Pointer Subterfuge Exploitation
 * 1. The attacker must exploit a vulnerability allowing
 *    unintended access to the pointer
 * 2. The attacker must be able to provide a new pointer
 *    referring to data altering the normal flow of the program
 ****************************************/
void subterfugeExploit()
{
    // an attacker's array
    long int array[3] =             // 1. Exploit
    {
        0,
        1,
        (long int)"!!!!!!!!!!!!! You've been hacked !!!!!!!!!!!!!\n"
        // 2. Provide pointer
    };
    
    // exploit it
    subterfugeVulnerability(array, 3);
}

/**************************************************************
 **************************************************************
 ********************    STACK       **************************
 **************************************************************
 **************************************************************/

/***********************************************
 * STACK VULNERABILITY
 * 1. There must be a buffer on the stack
 * 2. the buffer must be reachable from an external input
 * 3. The mechanism to fill the buffer must not check the correct buffersize
 **********************************************/
void stackVulnerability(long int userInput[], long int size)
{
    // Accepts a userInput buffer along with its size
    // Copies the input buffer into a buffer of size 1
    
    long int uncheckedBuffer[1]; //Small stack variable is 1 byte long.
    
    // Array is copied
    for (long int i = 0; i < size; i++)
    {
        uncheckedBuffer[i] = userInput[i];
        cout << i << " " << uncheckedBuffer[i] << endl;
    }
}

/*********************************************
 * STACK EXPLOIT
 * 1. The attacker must provide more data into the
 *    outwardly facing buffer than the buffer is designed to hold
 * 2. The attacker must know where the the stack pointer resides
 *    on the stack. This should be just beyond the end of the buffer
 * 3. The attacker must insert machine language instructions in the buffer.
 *    This may occur before, after, or even around the stack pointer. The
 *    machine language could be already compiled code in the program
 * 4. The attacker must overwrite the stack pointer. The old value,
 *    directing the flow of the program after the function is returned,
 *    must be changed from the calling function to the provided
 *    machine language in step 3.
 *********************************************/
void stackExploit()
{
    // Creates a buffer that is longer than it should be.
    // Adds a function pointer at the end.
    
    long int buffer[10] = {0, 1, 2, 3, 4, (long int) &stackSmasher};
    int size = sizeof(buffer) / sizeof(buffer[0]);
    
    cout << "This exploit is demonstrated by inserting a function address into the call stack" << endl;
    cout << "This is an example of how a dangerous function call can be introduced into the stack" << endl;
    
    stackVulnerability(buffer, size);
    
    cout << "Stack smashed" << endl;
}

/**
 * Displays message once stack has been smashed
 */
void stackSmasher()
{
    cout << "Smashed!" << endl;
}

/**************************************************************
 **************************************************************
 ********************      HEAP      **************************
 **************************************************************
 **************************************************************/


/*************************************
 * HEAP VULNERABILITY
 * 1. There must be two adjacent heap buffers.
 * 2. The first buffer must be reachable through external input.
 * 3. The mechanism to fill the buffer from the external input must
 *    not correctly check for the buffer size.
 * 4. The second buffer must be released before the first.
 *************************************/
void heapVulnerability(long int *userInput, int size)
{
    // Two buffers are created on the heap
    long int *vulBuffer1 = new long[2];
    long int *vulBuffer2 = new long[2];
    
    // First buffer is overwritten without checking bounds
    for (int i = 0; i < size; i++)
    {
        vulBuffer1[i] = userInput[i];
    }
    
    // remove the second buffer before the first
    delete[] vulBuffer2;
    delete[] vulBuffer1;
}

/*************************************
 * HEAP EXPLOIT
 * 1. The attacker must provide more data into the outwardly facing
 *    heap buffer than the buffer is designed to hold
 * 2. The attacker must know the layout of the Memory Control Block (MCB)
 *    (essentially a linked list) residing just after the buffer
 * 3. The attacker must provide a new MCB containing both the location
 *    of the memory overwrite and the new data to be overwritten
 ***********************************/
void heapExploit()
{
    // This buffer inserts new values into heap
    long int buffer[6] = {-5, -5, -5, -5, -5, -5};
    
    cout << "Inserting too many values to crash the heap" << endl;
    heapVulnerability(buffer, sizeof(buffer) / sizeof(buffer[0]));
}

/**************************************************************
 **************************************************************
 ********************     ARRAY      **************************
 **************************************************************
 **************************************************************/

/*************************************
 * ARRAY VULNERABILTY
 * 1. There must be an array and an array index variable
 * 2. The array index variable must be reachable through external input.
 * 3. There must not be bounds checking on the array index variable.
 ************************************/
void arrayVulnerability(int i, int userInput)
{
    int array[2] = {1, 2}; // initialize array
    
    assert(array[i] == 0); // For debugging
    
    // Set the ith value of the array to the provided value with no bounds checking
    cout << "Putting in address " << hex << &array[i] << endl;
    array[i] = userInput;
}

/**************************************
 * ARRAY EXPLOIT
 * 1. The attacker provides an array index value outside the expected range
 * 2. The attacker must be able to provide input or redirect
 *    existing input into the array at the index he provided
 * 3. The injected value must alter program state in a way
 *    that is desirable to the attacker
 *************************************/
void arrayExploit()
{
    // Create variable
    int exploitValue = 0;
    
    cout << "Demonstrating an array index exploit by changing the value of exploitValue" << endl;
    cout << "Initial exploitValue: " << exploitValue << endl;
    cout << "exploitValue address: " << hex << &exploitValue << endl;
    
    // Pass an array index to access and a new value.
    // This exploit will use the unchecked array bounds
    // to change the value of exploitValue to 42.
    cout << "Using vulnerability to change the value of exploitValue" << endl;
    
    arrayVulnerability(15, 42);
    cout << "exploitValue is " << dec << exploitValue << endl;
}


/**************************************************************
 **************************************************************
 *******************    INTEGER      **************************
 **************************************************************
 **************************************************************/

/********************************************
 * INTEGER VULNERABILITY
 * 1. There must be a security check represented by an expression.
 * 2. The expression must have the potential for overflow.
 * 3. At least one of the numbers used to compute the sentinel
 *    must be reachable through external input.
 *********************************************/
void intVulnerability(char exploitBuffer[], unsigned char size, int index, int exploitVal)
{
    if ((unsigned char) index <= size && index >= 0)
    {
        cout << "Inserting address: " << hex << &exploitBuffer[index] << endl;
        exploitBuffer[index] = exploitVal;
    }
    else
    {
        cout << dec << (unsigned char) index << endl;
    }
}

/**********************************************
 * INTEGER EXPLOIT
 * 1. Provide input, either a buffer size or a single value,
 *    that is directly or indirectly used in the vulnerable expression
 * 2. The input must exceed the valid bounds of the data-type,
 *    resulting in an overflow or underflow condition
 **********************************************/
void intExploit()
{
    // Create new buffer
    char buffer[256];
    
    // This variable will be changed using the exploit
    int exploitValue = 0;
    
    // Finding the correct address
    cout << "Integer overflow exploit will be used to change value of exploitValue" << endl;
    cout << "Initial value: " << dec << exploitValue << endl;
    cout << "Exploit Value address: " << hex << &exploitValue << endl;
    
    // The number 268 is used to cast an unsigned
    // char for comparison and overflows resulting
    // in a zero. This bypasses the size check comparison
    // because the index is still > 0 when it isn't cast.
    // This allows us to change the value of exploitValue
    
    cout << "Demonstrate the exploit" << endl;
    intVulnerability(buffer, 255, 268, 42);
    
    cout << "exploitValue is: " << dec << exploitValue << endl;
}

/**************************************************************
 **************************************************************
 ********************      ARC       **************************
 **************************************************************
 **************************************************************/

/**
 * The function that is supposed to be executed
 * by the ARC Vulnerability function
 */
void favoriteNumber()
{
    cout << "My favorite number is 123" << endl;
}

/**
 * The function we will call using
 * the ARC exploit function
 */
void exploitedFavoriteNumber()
{
    cout << "Hacked!" << endl;
}

/*********************************
 * ARC VULNERABILITY
 * 1. There must be a function pointer used in the code.
 * 2. Through some vulnerability, there must be a way for user input
 *    to overwrite the function pointer. This typically happens through
 *    a stack buffer vulnerability.
 * 3. After the memory is overwritten, the function pointer must
 *    be dereferenced
 ********************************/
void arcVulnerability(long *userInput, int size)
{
    // Create a buffer for user input
    long uncheckedBuffer[2];
    
    // Function pointer located right after buffer
    void (*pntFunc)() = favoriteNumber;
    
    for (int i = 0; i < size; i++)
    {
        // Copy userInput into buffer without size check
        uncheckedBuffer[i] = userInput[i];
    }
    
    // Call function pointer to favoriateNumber()
    pntFunc();
}

/*********************************
 * ARC EXPLOIT
 * 1. The attacker must exploit a vulnerability allowing
 *    unintended access to the function pointer
 * 2. The attacker must have the address to another function
 *    which is to be used to replace the existing function pointer
 ********************************/
void arcExploit()
{
    // Create payload with a pointer to a new function
    long payload[3] = {0, 0, (long) exploitedFavoriteNumber};
    
    cout << "arcVulnerability() should call favoriteNumber() to "
        << "display it's message.\n"
        << "Through the user of ARC injection, the function "
        << "pointer will be overwriten with a pointer to a "
        << "different function." << endl;
    
    arcVulnerability(payload, 3);
}

/**************************************************************
 **************************************************************
 ********************     VTABLE     **************************
 **************************************************************
 **************************************************************/

/***********************************
 * VULNERABILITY
 * 1. The vulnerable class must be polymorphic.
 * 2. The class must have a buffer as a member variable.
 * 3. Through some vulnerability, there must be a way for user input
 *    to overwrite parts of the VTable.
 * 4. After a virtual function pointer is overwritten,
 *    the virtual function must be called.
 **********************************/
class Vulnerability
{
public:
    // buffer to overflow
    long buffer[2];
    
    // function to set buffer with no bounds
    void setBuffer(long newValue, int i)
    {
        buffer[i] = newValue;
    }
    
    // Virtual function to be implemeted in children
    virtual void getBuffer() = 0;
};

// Child class that inherits vulnerable code
class Vulnerable : public Vulnerability
{
public:
    
    virtual void getBuffer()
    {
        cout << "Buffer contents " << buffer[0]
            << " " << buffer[1] << endl;
    }
};

/************************************
 * VTABLE EXPLOIT
 * 1. Through some vulnerability, the VTable pointer
 *     or a function pointer within the VTable must be overwritten
 * 2. The attacker must have the address to another VTable pointer
 *     or a function pointer
 ***********************************/
void vtableExploit()
{
    // New class instance
    Vulnerable exploit;
    // Function pointer
    void (*pntFun)() = exploitedFavoriteNumber;
    
    cout << "This demonstrates VTABLE exploit by overwriting "
    << "the pointer to getBuffer method on the vtable"
    << "inserting the pointer to the exploit function instead."
    << endl;
    
    exploit.setBuffer((long) pntFun, -2);
    
    exploit.getBuffer();
}


/**************************************************************
 **************************************************************
 ******************    ANSI-Unicode    ************************
 **************************************************************
 **************************************************************/

/*********************************************************
 * ANSI - UNICODE VULNERABILITY
 * 1. There must be a buffer where the basetype is greater than one.
 * 2. Validation of the buffer must check the size of the buffer
 *    rather than the number of elements in the buffer.
 ********************************************************/
short *ansiVulnerability(const char *inputText, int size)
{
    // Allocated new array on heap
    short *toCopy = new short;
    
    for (int i = 0; i < size; i++)
    {
        toCopy[i] = (short) inputText[i];
    }
    
    return toCopy;
}

/***********************************************
 * ASCI - UNICODE EXPLOIT
 * 1. The attacker must provide more than half as much data
 *    into the outwardly facing buffer as it is designed to hold
 **********************************************/
void ansiExploit()
{
    short *value = ansiVulnerability("abcdefghijklmnopqrstuvwxyz", 26);
    delete value;
}
